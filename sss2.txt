Nice — that repo is a great launchpad because all the hard Vulkan RT plumbing is already there. Here’s a “fastest path” way to bolt in homogeneous random-walk SSS with minimal disruption.

Goal

When a ray hits an SSS material:

do the normal surface stuff (optional specular),

then do a few “inside” scattering steps,

and when the walk “exits” the object, sample lighting (environment / direct light) at that exit point.

This gives you the classic “glowy wax” look quickly.

1) Pick the tutorial step to modify

Use a step that already has:

closest-hit shading

shadows or environment lighting

In that repo, a good place is whatever chapter you’re using that already does lighting in closesthit.rchit (and has a miss shader for environment). If you already see a lit model, you’re good.

2) Add SSS material parameters

You need per-material (or per-instance) parameters:

sigma_s (RGB)

sigma_a (RGB)

Minimal storage options:

Option A (fastest to wire): per-instance values in an SSBO indexed by gl_InstanceCustomIndexEXT.
Option B: per-material array indexed by your existing material id.

If the tutorial already uses gl_InstanceCustomIndexEXT to pick a material/texture, piggyback on that.

Example struct:

struct SssParams {
  vec3 sigma_s;
  float pad0;
  vec3 sigma_a;
  float pad1;
};

3) You must be able to identify “same object” when tracing from inside

During the random walk you’ll trace a ray segment of length s and ask:

did we hit this same instance before distance s?

If yes: still inside, continue walking.
If no: we “exited” (or didn’t hit anything), stop and light that exit point.

So your “segment test” payload needs at least:

hitT

hitInstanceCustomIndex (or hitInstanceId)

Example payload:

struct SegPayload {
  float t;
  int   inst;
  int   hit;
};


Initialize hit = 0.

In the closest-hit for that segment ray:

set hit=1

record t = gl_HitTEXT

record inst = gl_InstanceCustomIndexEXT

Then the walk compares inst == currentInst.

4) Trace “inside segment” rays correctly (important flags)

When you’re inside geometry you usually want backfaces to count, otherwise you may miss the boundary.

So for segment rays:

disable culling of backfaces

and keep it “closest hit” only

In traceRayEXT, use flags like:

do not include gl_RayFlagsCullBackFacingTrianglesEXT

you can use gl_RayFlagsTerminateOnFirstHitEXT to speed up if your scene uses watertight meshes and you only care about “any hit before s”.

However: if there are multiple hits, “first hit” isn’t necessarily the closest unless traversal guarantees it. Safer: no terminate, let closest-hit choose closest.

For a fast example, I recommend no terminate first (correct), then optimize later.

Also:

tMin should be a small epsilon (e.g. 1e-4) to avoid self-hit.

Start the walk at x0 - n0 * eps (slightly inside the surface).

5) Implement the random walk in the main closest-hit shader

Pseudo-structure inside your existing closest hit:

compute x0 world hit position and n0 world normal

look up SSS params

if material is SSS:

run sss_random_walk(...) which internally:

samples free-flight distance s from exponential distribution

segment-traces x -> x + w*s

if same instance hit within s: continue

else: exit point x_exit = x + w*s; evaluate lighting once and return

else: do normal shading

Key details:

Use a scalar sigma_t just to pick step lengths (fast):

sigma_t_scalar = luminance(sigma_s + sigma_a)

Attenuate throughput by albedo:

albedo = sigma_s / (sigma_s + sigma_a)

Optionally Beer absorption per step:

throughput *= exp(-sigma_a_scalar * s)

Keep it tiny:

MAX_STEPS = 4..8

One lighting sample on exit is enough for “it works”.

6) Lighting at the exit point (keep it simple)

Fastest:

environment only: shoot a single ray in a cosine hemisphere around the exit normal (or just use -w as “outgoing”) and call your existing traceRayEXT for radiance.

or one direct-light shadow ray if the tutorial already has a light source path.

If the tutorial already has a “raygen does next-event estimation / direct lighting” you can mimic that in the closest hit, but simplest is:

reuse the same “trace a ray to get radiance” function you already have (or payload + miss shader).

7) Debug checklist when it doesn’t work

If you get black / NaNs / stuck inside:

Backface culling still enabled on segment rays → you’ll never detect boundary from inside.

Epsilon wrong → self-intersections: increase tMin and the initial “push inside”.

You’re comparing the wrong instance key → use gl_InstanceCustomIndexEXT consistently for both the original hit and the segment hit.

Your BLAS instances share the same custom index → ensure each instance gets a unique one if you’re using it as identity.

8) Starter parameters that will look SSS immediately

Wax-ish:

sigma_s = (2.0, 1.0, 0.5)

sigma_a = (0.1, 0.05, 0.02)

steps: 6

Skin-ish toy:

sigma_s = (1.5, 1.0, 0.7)

sigma_a = (0.4, 0.2, 0.1)

steps: 6–8

If you tell me one thing, I can make this “surgical”

In your build, which tutorial sample are you running (folder / chapter name), and does it already have:

environment map miss shader (yes/no)

direct light shadows (yes/no)

With that, I can point to the exact shader file(s) to edit and the exact payload structs you should add so it compiles on the first try.
